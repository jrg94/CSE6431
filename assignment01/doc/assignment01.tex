\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{minted}
\usepackage{color}
\usepackage[english]{babel}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}

%
% Minted Settings
%

\setminted{frame=lines}
\setminted{linenos}
\setminted{autogobble}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problem \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Assignment\ \#1}
\newcommand{\hmwkDueDate}{February 05, 2019}
\newcommand{\hmwkClass}{CSE 6431}
\newcommand{\hmwkClassInstructor}{Professor Qin}
\newcommand{\hmwkAuthorName}{\textbf{Jeremy Grifski}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate\ at 11:10am}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor}}
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%


% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Implement a solution with writers’ priority to the readers/writers problem
        using semaphores.
    }

    Alright, this problem is going to need a bit of explaining because this
    solution is very complicated. To start, we have the reader procedure
    which is split into two parts leveraging three mutexes and four variables.
    The four variables are readers_waiting, readers_reading, writers_writing,
    and writers_waiting.

    To get into the procedure, the process needs to aquire the sr_mutex. After
    that, the reader assesses its ability to read which is based on writers
    due to the writers priority. If it's safe to read, the process increments
    the readers_reading variable and frees the reader_mutex. Otherwise, the process
    increments the readers_waiting variable. In either case, the process frees
    the sr_mutex before asking for the reader_mutex.

    Once the process aquires the reader_mutex, it reads before attempting
    to acquire the sr_mutex. If successful, the process decrements the
    readers_reading variable and attempts to give control to writers as long
    as their are writings waiting and there are no active readers. Finally,
    the process gives up the sr_mutex.

    \begin{minted}{text}
        Procedure reader
          P(sr_mutex)
          if writers_writing > 0 or writers_waiting > 0 then
            readers_waiting++
          else
            V(reader_mutex)
            readers_reading++
          V(sr_mutex)

          P(reader_mutex)
          <read file>

          P(sr_mutex)
          readers_reading--
          if readers_reading = 0 and writers_waiting > 0 then
            V(writer_mutex)
            writers_waiting--
            writers_writing++
          V(sr_mutex)

        Procedure writer
          P(sr_mutex)
          P(writer_mutex)

          <write file>

          V(writer_mutex)
          V(sr_mutex)
    \end{minted}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Implement a solution to the readers/writers problem using monitors which
        execute the requests in FCFS manner. If there are consecutive readers,
        they should be able to access the file concurrently.
    }

    In this solution, we track two variables: the numbers or readers and the
    number of writers. In addition, we also use a shared queue, so that all
    jobs are queued in FCFS order. Readers can only read if there are no writers,
    and writers can only writer if there are no readers. However, readers can
    read concurrently as their function is split into two.

    \begin{minted}{text}
        Procedure startRead
          begin
            if (writers > 0) then all.wait;
            readers++;
          end

        Procedure endRead
          begin
            readers--;
            if (readers == 0) then all.signal;
          end

        Procedure writer
          begin
            writers++;
            if (readers > 0) then all.wait;
            <write file>
            writers--;
            all.signal
          end
    \end{minted}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Write a semaphore-based solution to the reader–writers problem that works as
        follows: If readers and writers are both waiting, then it alternates between
        readers and  writers. Otherwise, it processes them normally, i.e., readers
        concurrently and writers serially.
    }

    \begin{minted}{text}
        Procedure reader
          P(reader_mutex)
          if readers = 0 then
            readers = readers + 1
            P(writer_mutex)
          else
            readers = readers + 1
          V(reader_mutex)

          <read file>

          P(reader_mutex)
          readers = readers - 1
          if readers == 0 then V(writer_mutex)
          V(reader_mutex)

        Procedure writer
          P(sr_mutex)
          P(writer_mutex)

          <write file>

          V(writer_mutex)
          V(sr_mutex)
    \end{minted}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Write a monitor-based solution to the above problem.
    }

    \begin{minted}{text}
        Procedure startRead
          begin
            readers = readers + 1;
          end

        Procedure endRead
          begin
            readers = readers - 1;
            if (readers == 0) then writer.signal;
          end

        Procedure writer
          begin
            if (readers > 0) then writer.wait;
            <write file>
          end
    \end{minted}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        A file is to be shared among different processes, each of which has a unique
        number. The file can be accessed simultaneously by several processes, subject
        to the following constraint: The sum of all unique numbers associated with all
        the processes concurrently accessing the file must be less than n. Write a
        monitor to coordinate accesses to the file.
    }

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Using Java support for multithreading (Synchronized, wait, and notifyall),
        write a solution to the producer-consumer problem with a buffer of length N.
        Submit your solution on paper (i.e. do not worry about exact syntax or debugging).
    }

    The following solution demonstrates just the shared memory portion of the
    producers/consumers problem. In addition to this class, you'd need to create
    producer and consumer classes which call the produce and consume methods
    in some way.

    \begin{minted}{java}
        /**
         * A shared memory space class with functions for consumption and production.
         *
         * @author Jeremy Grifski
         */
        public class Buffer {
          private ArrayList<Integer> buffer;
          private maxSize;

          public Buffer(int maxSize) {
            this.buffer = new ArrayList<Integer>();
            this.maxSize = maxSize;
          }

          /**
           * A production method which generates a random value between 0 and 1000
           * and places it at the end of shared memory.
           */
          public synchronized void produce() {
            while (buffer.size() == maxSize) {
              try {
                wait();
              } catch (InterruptedException e) {
                System.out.println("Producer awoken!");
              }
            }
            this.buffer.add((int)(Math.random() * 1000));
            notifyAll();
          }

          /**
           * A consumption method which consumes the first value from the buffer.
           */
          public synchronized int consume() {
            while(buffer.isEmpty()) {
              try {
                wait();
              } catch (InterruptedException e) {
                System.out.println("Consumer awoken!");
              }
            }
            int value = this.buffer.remove(0);
            notifyAll();
            return value;
          }
        }
    \end{minted}

    As you can see, this solution leverages all that is asked via synchronized,
    wait, and notifyAll. The following code snippets are the class stubs for
    the producer and consumer classes:

    \begin{minted}{java}
        public class Producer extends Thread {
          private Buffer sharedMemory;

          public Producer(Buffer sharedMemory) {}

          public void run() {
            // Implement production loop
          }
        }
    \end{minted}

    \begin{minted}{java}
        public class Consumer extends Thread {
          private Buffer sharedMemory;

          public Consumer(Buffer sharedMemory) {}

          public void run() {
            // Implement consumption loop
          }
        }
    \end{minted}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Using Java support for multithreading (Synchronized, wait, and notifyall),
        write a solution to the readers-writers problem, with exclusive writer access,
        concurrent reader access, and reader’s priority. Submit your solution on paper
        (i.e. do not worry about exact syntax or debugging).
    }

    In this solution, I tried to model everything after the existing readers and
    writers solution using monitors. Instead of using a busy flag, I used a
    writers count which serves the exact same purpose. Since there are no queues
    to control directly, I notify all every time a process finishes and let the
    start loops sort everything out.

    Once again, you'll notice that I don't provide the Reader and Writer clases
    as they're more or less not important. The main shared resource logic
    is here in the SharedFile class. Regardless, the class stubs would look
    similar to the ones displayed in the previous problem.

    \begin{minted}{java}
        /**
         * A shared file with functionality for reading and writing.
         *
         * @author Jeremy Grifski
         */
        public class SharedFile {

          private int readCount;
          private int writeCount;

          public SharedFile() {
            this.readCount = 0;
            this.writeCount = 0;
          }

          /**
           * A start read method which kicks off reading iff there are no writers.
           */
          public synchronized void startRead() {
            while (writeCount > 0) {
              try {
                wait();
              } catch (InterruptedException e) {
                System.out.println("Reader wants to read!");
              }
            }
            readCount++;
            notifyAll();
          }

          /**
           * An end read method which notifies everyone when there are no readers left.
           */
          public synchronized void endRead() {
            readCount--;
            if (this.readCount == 0) {
              notifyAll();
            }
          }

          /**
           * A start write method which kicks off writing if there are no other readers
           * or writers.
           */
          public synchronized void startWrite() {
            while (readCount > 0 || writeCount > 0) {
              try {
                wait();
              } catch (InterruptedException e) {
                System.out.println("Writer wants to write!")
              }
            }
            writeCount++;
          }

          /**
           * An end write method whichs notifies everyone when writing is done.
           */
          public synchronized void endWrite() {
            writeCount--;
            notifyAll();
          }

        }
    \end{minted}

\end{homeworkProblem}

\end{document}
