\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{minted}
\usepackage{color}
\usepackage[english]{babel}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}

%
% Minted Settings
%

\setminted{frame=lines}
\setminted{linenos}
\setminted{autogobble}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problem \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Assignment\ \#2}
\newcommand{\hmwkDueDate}{February 28, 2019}
\newcommand{\hmwkClass}{CSE 6431}
\newcommand{\hmwkClassInstructor}{Professor Qin}
\newcommand{\hmwkAuthorName}{\textbf{Jeremy Grifski}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate\ at 11:10am}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor}}
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%


% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Lamport’s algorithm requires messages to be delivered in FIFO
        order between every pair of sites. Does Ricart-Agrawala’s algorithm
        require the same assumption to work? Explain your answer.
    }

    No! Since each process requires a REPLY from all other processes to begin
    executing their critical section AND the process with the lowest timestamp
    gets priority, there's no opportunity for multiple processes to hit
    their critical section at the same time even without the FIFO assumption.

    This differs from Lamport's algorithm because replies are combined with
    releases. In Lamport's algorithm, replies grant access to the critical
    section based on each process's local queue. If the communication channels
    are not FIFE, it's possible that the queues are not the same for all
    processes which means multiple processes can enter their critical section
    simultaneously. This is not a problem with the Ricart-Agrawala solution.

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Show that in Lamport’s distributed mutual exclusion algorithm, the
        critical section is accessed according to the increasing order
        of timestamps. Then, show that the same property holds true in
        Ricart-Agrawal’s distributed mutual exclusion algorithm. Does the same
        hold true in Maekawa’s algorithm?
    }

    In Lamport's algorithm, the critical section is accessed according to the
    increasing order of timestamps due to the way request queues are handled.
    Every time a process receives a request, the request is placed onto that
    process's request queue in order of timestamp. These queues are synchronized
    between every processes, so all processes are aware of the order. At any
    given time, only the process with the smallest timestamp in the request
    queue can access its critical section.

    In Ricart-Agrawala's algorithm, the critical section is accessed according
    to the increasing order of timestamps due to the way replies are managed.
    Processes only send replies under two conditions:

    \begin{enumerate}
      \item They're not making a request
      \item They're making a request, but their timestamp is greater than an
      incoming request
    \end{enumerate}

    The second condition guarantees that processes access their critical section
    in increasing order of timestamps.

    Finally, the premise that the critical section is accessed according to the
    increasing order of timestamps does not hold for Maekawa's algorithm. It's
    precisely this fact which makes Maekawa's algorithm deadlock prone. Without
    using priority based on timestamps, the algorithm may generate a cycle between
    request sites which results in a deadlock.

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        If two logs are equivalent, are their serialization graphs identical? If
        yes, show your proof. Otherwise, give me a counter-example.
    }

    Yes!

    The idea that two equivalent logs have the same serialization graph
    comes from the idea that topological sorts of serialization graphs are
    not unique. In other words, there may be multiple ways to topologically sort
    a serialization graph which can yield multiple equivalent logs. To prove this,
    you'd have to show that

    Since a log
    can only produce one serialization graph, two logs producing the same
    serialization graph must be topological sorting permutations of the
    same serialization graph.

    Or, more formally by contradiction:

    \begin{enumerate}
      \item Assume two logs, L1 and L2, are equivalent
      \item Assume two logs, L1 and L2, have different serialization graphs
      \item This would mean that both sets of transactions see the same state of
      the database and leave the database in the same final state, but their
      serialization graphs differ
      \item For that to be possible, there should be a way to construct the
      exact same sets of topological sorts from the two different serialization
      graphs
    \end{enumerate}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Consider a database system in which a set of transactions are executed.
        There are two requirements for correct execution of the transactions.
        First, the log of execution of operations in these transactions must be
        serializable. Second, the equivalent serial execution must follow a
        given partial order among the transactions. Describe a concise approach
        for verifying that the above two conditions are met by a log.
    }

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Assume a system has P processes and R identical units of a reusable
        resource. If each process can claim at most N units of a resource, show
        that the system will be deadlock free if and only if R >= P(N-1) + 1.
    }

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}

    \textbf{
        Consider a system consisting of m resources of the same type, being
        shared by n processes. Resources can be requested or released by
        processes only one at a time. Show that the system is deadlock free if
        the following two conditions hold:
        1) the maximum need of each process is between 1 and m resources, and
        2) the sum of all maximum needs is less than m + n.
    }

\end{homeworkProblem}

\end{document}
